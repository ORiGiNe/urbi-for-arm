#! /usr/bin/python

def iif(cond, iftrue, iffalse):
    if cond:
        return iftrue
    else:
        return iffalse

## ----------- ##
## Boost types ##
## ----------- ##

def boost_param(r, nargs):

    args = []
    if r:
        args += ['R']
    else:
        args += ['void']
    if nargs != -1:
        args += 'S'
    for i in range(nargs):
        args += ['Arg%s' % i]
    return args


def boost_function(args):

    # Leave trailing space to avoid outputting '>>'
    return 'boost::function%s<%s> ' % (len(args) - 1, ', '.join(args))


def boost_type(r, nargs):

    args = boost_param(r, nargs)
    return boost_function(args)


def boost_list_type(r, met):

    args = boost_param(r, 0)
    if not met:
        args = args[:-1]
    args += ['const object::objects_type&']
    return boost_function(args)


def primitive(r, nargs):

    ## HELPERS ##

    # Convert argument n from Urbi to type
    def to(n, type):
        return 'from_urbi<typename Flatten<%s>::type>(args[%s], %s)'\
               % (type, n, n)

    def make_arg(n):
        return to(n + 1, 'Arg%s' % n)

    # Generate template parameters list
    def template_param(r, nargs):

        def add_typename(arg):
            return 'typename %s' % arg

        args = []
        if r:
            args += ['R']
        if nargs != -1:
            args += ['S']
        for i in range(nargs):
            args += ['Arg%s' % i]
        args = map(add_typename, args)
        return ', '.join(args)

    # Generate the list of effective arguments for the wrapped function
    # as a possibly empty string.
    def arguments(nargs):
        if nargs != -1:
            args = [to(0, 'S')] + map(make_arg, range(nargs))
            return ',\n           '.join(args)
        else:
            return ''

    if r:
        r = 'return CxxConvert<typename Flatten<R>::type>::from'
        r_void = ''
    else:
        r = ''
        r_void = 'return object::void_class;'

    return '''\
    template <%(param)s>
    struct MakePrimitive<%(boost)s>
    {
      static rObject primitive(const object::objects_type& %(args_name)s,
                               %(boost)s f)
      {
        %(check)s
        %(return)s
        (f(%(args)s));
        %(return_void)s
      }
    };
    ''' % {
        'args': arguments(nargs),
        'args_name': iif(nargs != -1, 'args', ''),
        'boost': boost_type(r, nargs),
        'check': iif(nargs != -1,
                     'check_arg_count(args.size() - 1, %s);' % nargs,
                     ''),
        'nargs': nargs,
        'param': template_param(r, nargs),
        'return': r,
        'return_void': r_void,
        'self': to(0, 'S'),
        }

primitives = ''

for ret in [True, False]:
    # nargs counts "this".  -1 means there is not even a this.
    for nargs in [-1] + range(10):
        primitives += '\n    // Return: %s, Arguments: %s\n' % (ret, nargs)
        primitives += primitive(ret, nargs)

print '''// This file is autogenerated from cxx-primitive.hxx.py -- Do not modify

#include <boost/bind.hpp>
#include <boost/tr1/type_traits.hpp>

#include <urbi/object/any-to-boost-function.hh>
#include <urbi/object/cxx-conversions.hh>
#include <urbi/object/cxx-primitive.hh>
#include <urbi/object/primitive.hh>

namespace urbi
{
  namespace object
  {
    template <typename M>
    struct MakePrimitive
    {};

    namespace
    {
      // Remove const and reference
      template <typename T>
      struct Flatten
      {
        typedef typename boost::remove_const
        <typename boost::remove_reference<T>::type>::type type;
      };
    }

  %s;

    template<typename M>
    inline rPrimitive
    primitive(M f)
    {
      return primitive(new Primitive, f);
    }

    template<typename M>
    inline rPrimitive
    primitive(rPrimitive p, M f)
    {
      p->extend(f);
      return p;
    }

    template<typename M>
    void
    Primitive::extend(M f)
    {
      // If primitive is unfound in MakePrimitive here, you gave an
      // unsupported type to make Primitive. AnyToBoostFunction must be
      // able to convert the given values. It handles:
      // * boost::functions
      // * function pointers
      // * method pointers
      typedef AnyToBoostFunction<M> C;
      aver(!libport::mhas(content_, C::arity));
      content_[C::arity] =
        boost::bind(MakePrimitive<typename C::type>::primitive,
                    _1, /*_2,*/ C::convert(f));
    }

    inline void
    setter_bouncer(rObject self,
                   const std::string&, rObject value, const std::string& name)
    {
      self->call(name, value);
    }

    template <typename F1, typename F2>
    inline void
    Object::bind(const std::string& getter_name, F1 getter,
                 const std::string& setter_name, F2 setter)
    {
      slot_set(libport::Symbol(getter_name), primitive(getter));
      slot_set(libport::Symbol(setter_name), primitive(setter));
      boost::function3<void, rObject, const std::string&, rObject>
        f(boost::bind(&setter_bouncer, _1, _2, _3, setter_name));
      setProperty(getter_name, "updateHook", primitive(f));
    }

    template <typename Return, typename Self>
    struct bind_variadic_bouncer
    {
      static rObject
      f(const objects_type& args,
        const boost::function2<Return, Self*, const objects_type&>& f)
      {
        assert(!args.empty());
        objects_type args_left(args.begin() + 1, args.end());
        Self* self = from_urbi<Self*>(args[0], 0);
        return CxxConvert<Return>::from(f(self, args_left));
      }
    };

    template <typename Self>
    struct bind_variadic_bouncer<void, Self>
    {
      static rObject
      f(const objects_type& args,
        const boost::function2<void, Self*, const objects_type&>& f)
      {
        assert(!args.empty());
        objects_type args_left(args.begin() + 1, args.end());
        Self* self = from_urbi<Self*>(args[0], 0);
        f(self, args_left);
        return void_class;
      }
    };

    template <typename Return, typename Self>
    void
    Object::bind_variadic(const std::string& name,
                          const boost::function2<Return, Self*, const objects_type&>& val)
    {
      setSlot(name, new Primitive(boost::bind(bind_variadic_bouncer<Return, Self>::f, _1, val)));
    }

    template <typename Return, typename Self>
    void
    Object::bind_variadic(const std::string& name,
                          Return (Self::*val)(const objects_type&))
    {
      bind_variadic(name, boost::function2<Return, Self*, const objects_type&>(val));
    }
  }
}''' % primitives
