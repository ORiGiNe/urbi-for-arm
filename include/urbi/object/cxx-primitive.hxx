// This file is autogenerated from cxx-primitive.hxx.py -- Do not modify

#include <boost/bind.hpp>
#include <boost/tr1/type_traits.hpp>

#include <urbi/object/any-to-boost-function.hh>
#include <urbi/object/cxx-conversions.hh>
#include <urbi/object/cxx-primitive.hh>
#include <urbi/object/primitive.hh>

namespace urbi
{
  namespace object
  {
    template <typename M>
    struct MakePrimitive
    {};

    namespace
    {
      // Remove const and reference
      template <typename T>
      struct Flatten
      {
        typedef typename boost::remove_const
        <typename boost::remove_reference<T>::type>::type type;
      };
    }

  
    // Return: True, Arguments: -1
    template <typename R>
    struct MakePrimitive<boost::function0<R> >
    {
      static rObject primitive(const object::objects_type& ,
                               boost::function0<R>  f)
      {
        
        return CxxConvert<typename Flatten<R>::type>::from
        (f());
        
      }
    };
    
    // Return: True, Arguments: 0
    template <typename R, typename S>
    struct MakePrimitive<boost::function1<R, S> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function1<R, S>  f)
      {
        check_arg_count(args.size() - 1, 0);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0)));
        
      }
    };
    
    // Return: True, Arguments: 1
    template <typename R, typename S, typename Arg0>
    struct MakePrimitive<boost::function2<R, S, Arg0> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function2<R, S, Arg0>  f)
      {
        check_arg_count(args.size() - 1, 1);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1)));
        
      }
    };
    
    // Return: True, Arguments: 2
    template <typename R, typename S, typename Arg0, typename Arg1>
    struct MakePrimitive<boost::function3<R, S, Arg0, Arg1> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function3<R, S, Arg0, Arg1>  f)
      {
        check_arg_count(args.size() - 1, 2);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2)));
        
      }
    };
    
    // Return: True, Arguments: 3
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2>
    struct MakePrimitive<boost::function4<R, S, Arg0, Arg1, Arg2> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function4<R, S, Arg0, Arg1, Arg2>  f)
      {
        check_arg_count(args.size() - 1, 3);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3)));
        
      }
    };
    
    // Return: True, Arguments: 4
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
    struct MakePrimitive<boost::function5<R, S, Arg0, Arg1, Arg2, Arg3> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function5<R, S, Arg0, Arg1, Arg2, Arg3>  f)
      {
        check_arg_count(args.size() - 1, 4);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4)));
        
      }
    };
    
    // Return: True, Arguments: 5
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
    struct MakePrimitive<boost::function6<R, S, Arg0, Arg1, Arg2, Arg3, Arg4> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function6<R, S, Arg0, Arg1, Arg2, Arg3, Arg4>  f)
      {
        check_arg_count(args.size() - 1, 5);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5)));
        
      }
    };
    
    // Return: True, Arguments: 6
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
    struct MakePrimitive<boost::function7<R, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function7<R, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5>  f)
      {
        check_arg_count(args.size() - 1, 6);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5),
           from_urbi<typename Flatten<Arg5>::type>(args[6], 6)));
        
      }
    };
    
    // Return: True, Arguments: 7
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
    struct MakePrimitive<boost::function8<R, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function8<R, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>  f)
      {
        check_arg_count(args.size() - 1, 7);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5),
           from_urbi<typename Flatten<Arg5>::type>(args[6], 6),
           from_urbi<typename Flatten<Arg6>::type>(args[7], 7)));
        
      }
    };
    
    // Return: True, Arguments: 8
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
    struct MakePrimitive<boost::function9<R, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function9<R, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7>  f)
      {
        check_arg_count(args.size() - 1, 8);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5),
           from_urbi<typename Flatten<Arg5>::type>(args[6], 6),
           from_urbi<typename Flatten<Arg6>::type>(args[7], 7),
           from_urbi<typename Flatten<Arg7>::type>(args[8], 8)));
        
      }
    };
    
    // Return: True, Arguments: 9
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
    struct MakePrimitive<boost::function10<R, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function10<R, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8>  f)
      {
        check_arg_count(args.size() - 1, 9);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5),
           from_urbi<typename Flatten<Arg5>::type>(args[6], 6),
           from_urbi<typename Flatten<Arg6>::type>(args[7], 7),
           from_urbi<typename Flatten<Arg7>::type>(args[8], 8),
           from_urbi<typename Flatten<Arg8>::type>(args[9], 9)));
        
      }
    };
    
    // Return: False, Arguments: -1
    template <>
    struct MakePrimitive<boost::function0<void> >
    {
      static rObject primitive(const object::objects_type& ,
                               boost::function0<void>  f)
      {
        
        
        (f());
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 0
    template <typename S>
    struct MakePrimitive<boost::function1<void, S> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function1<void, S>  f)
      {
        check_arg_count(args.size() - 1, 0);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 1
    template <typename S, typename Arg0>
    struct MakePrimitive<boost::function2<void, S, Arg0> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function2<void, S, Arg0>  f)
      {
        check_arg_count(args.size() - 1, 1);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 2
    template <typename S, typename Arg0, typename Arg1>
    struct MakePrimitive<boost::function3<void, S, Arg0, Arg1> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function3<void, S, Arg0, Arg1>  f)
      {
        check_arg_count(args.size() - 1, 2);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 3
    template <typename S, typename Arg0, typename Arg1, typename Arg2>
    struct MakePrimitive<boost::function4<void, S, Arg0, Arg1, Arg2> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function4<void, S, Arg0, Arg1, Arg2>  f)
      {
        check_arg_count(args.size() - 1, 3);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 4
    template <typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
    struct MakePrimitive<boost::function5<void, S, Arg0, Arg1, Arg2, Arg3> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function5<void, S, Arg0, Arg1, Arg2, Arg3>  f)
      {
        check_arg_count(args.size() - 1, 4);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 5
    template <typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
    struct MakePrimitive<boost::function6<void, S, Arg0, Arg1, Arg2, Arg3, Arg4> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function6<void, S, Arg0, Arg1, Arg2, Arg3, Arg4>  f)
      {
        check_arg_count(args.size() - 1, 5);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 6
    template <typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
    struct MakePrimitive<boost::function7<void, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function7<void, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5>  f)
      {
        check_arg_count(args.size() - 1, 6);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5),
           from_urbi<typename Flatten<Arg5>::type>(args[6], 6)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 7
    template <typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
    struct MakePrimitive<boost::function8<void, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function8<void, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>  f)
      {
        check_arg_count(args.size() - 1, 7);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5),
           from_urbi<typename Flatten<Arg5>::type>(args[6], 6),
           from_urbi<typename Flatten<Arg6>::type>(args[7], 7)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 8
    template <typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
    struct MakePrimitive<boost::function9<void, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function9<void, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7>  f)
      {
        check_arg_count(args.size() - 1, 8);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5),
           from_urbi<typename Flatten<Arg5>::type>(args[6], 6),
           from_urbi<typename Flatten<Arg6>::type>(args[7], 7),
           from_urbi<typename Flatten<Arg7>::type>(args[8], 8)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 9
    template <typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
    struct MakePrimitive<boost::function10<void, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function10<void, S, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8>  f)
      {
        check_arg_count(args.size() - 1, 9);
        
        (f(from_urbi<typename Flatten<S>::type>(args[0], 0),
           from_urbi<typename Flatten<Arg0>::type>(args[1], 1),
           from_urbi<typename Flatten<Arg1>::type>(args[2], 2),
           from_urbi<typename Flatten<Arg2>::type>(args[3], 3),
           from_urbi<typename Flatten<Arg3>::type>(args[4], 4),
           from_urbi<typename Flatten<Arg4>::type>(args[5], 5),
           from_urbi<typename Flatten<Arg5>::type>(args[6], 6),
           from_urbi<typename Flatten<Arg6>::type>(args[7], 7),
           from_urbi<typename Flatten<Arg7>::type>(args[8], 8),
           from_urbi<typename Flatten<Arg8>::type>(args[9], 9)));
        return object::void_class;
      }
    };
    ;

    template<typename M>
    inline rPrimitive
    primitive(M f)
    {
      return primitive(new Primitive, f);
    }

    template<typename M>
    inline rPrimitive
    primitive(rPrimitive p, M f)
    {
      p->extend(f);
      return p;
    }

    template<typename M>
    void
    Primitive::extend(M f)
    {
      // If primitive is unfound in MakePrimitive here, you gave an
      // unsupported type to make Primitive. AnyToBoostFunction must be
      // able to convert the given values. It handles:
      // * boost::functions
      // * function pointers
      // * method pointers
      typedef AnyToBoostFunction<M> C;
      aver(!libport::mhas(content_, C::arity));
      content_[C::arity] =
        boost::bind(MakePrimitive<typename C::type>::primitive,
                    _1, /*_2,*/ C::convert(f));
    }

    inline void
    setter_bouncer(rObject self,
                   const std::string&, rObject value, const std::string& name)
    {
      self->call(name, value);
    }

    template <typename F1, typename F2>
    inline void
    Object::bind(const std::string& getter_name, F1 getter,
                 const std::string& setter_name, F2 setter)
    {
      slot_set(libport::Symbol(getter_name), primitive(getter));
      slot_set(libport::Symbol(setter_name), primitive(setter));
      boost::function3<void, rObject, const std::string&, rObject>
        f(boost::bind(&setter_bouncer, _1, _2, _3, setter_name));
      setProperty(getter_name, "updateHook", primitive(f));
    }

    template <typename Return, typename Self>
    struct bind_variadic_bouncer
    {
      static rObject
      f(const objects_type& args,
        const boost::function2<Return, Self*, const objects_type&>& f)
      {
        assert(!args.empty());
        objects_type args_left(args.begin() + 1, args.end());
        Self* self = from_urbi<Self*>(args[0], 0);
        return CxxConvert<Return>::from(f(self, args_left));
      }
    };

    template <typename Self>
    struct bind_variadic_bouncer<void, Self>
    {
      static rObject
      f(const objects_type& args,
        const boost::function2<void, Self*, const objects_type&>& f)
      {
        assert(!args.empty());
        objects_type args_left(args.begin() + 1, args.end());
        Self* self = from_urbi<Self*>(args[0], 0);
        f(self, args_left);
        return void_class;
      }
    };

    template <typename Return, typename Self>
    void
    Object::bind_variadic(const std::string& name,
                          const boost::function2<Return, Self*, const objects_type&>& val)
    {
      setSlot(name, new Primitive(boost::bind(bind_variadic_bouncer<Return, Self>::f, _1, val)));
    }

    template <typename Return, typename Self>
    void
    Object::bind_variadic(const std::string& name,
                          Return (Self::*val)(const objects_type&))
    {
      bind_variadic(name, boost::function2<Return, Self*, const objects_type&>(val));
    }
  }
}
