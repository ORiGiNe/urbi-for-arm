/*
 * Copyright (C) 2010-2011, Gostai S.A.S.
 *
 * This software is provided "as is" without warranty of any kind,
 * either expressed or implied, including but not limited to the
 * implied warranties of fitness for a particular purpose.
 *
 * See the LICENSE file for more information.
 */

package urbi;

/**
\mainpage
This document is the autogenerated documentation for Urbi SDK Remote Java.

Classes of interest:
- Urbi connections: urbi::UAbstractClient, urbi::UClient, urbi::USyncClient.
- Data types: urbi::UValue, urbi::UBinary.
- UObject API: urbi::UObject, urbi::UVar.
*/

import gnu.bytecode.*;
import java.lang.Class;
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
import java.lang.RuntimeException;
import java.util.LinkedList;
import urbi.urbi;
import urbi.UObjectCPP;
import urbi.UVar;
import urbi.URBIStarterJAVA;
import urbi.UContextImpl;
import urbi.UValue;
import urbi.UrbiRoot;
import urbi.UAutoValue;
import urbi.UEvent;

/// This class is the base UObject class for Java UObject.
/// Please have all your Java UObject extends UObject
public class UObject extends UObjectCPP
{

    /// Constructor
    public UObject (String s) {
	super (s);
    }

    private boolean superdofinalize = true;

    protected void finalize() {
	// Call super finalize only when destruction originate from
	// JAVA.
	if (superdofinalize)
	    super.finalize();
    }

    // Hack to have java subclasses finalize() called when destruction
    // originare from C++.
    protected void swigDirectorDisconnect() {
	// Destruction originate from C++
	superdofinalize = false;
	// call subclass finalize if there are any
	finalize();
	// then let swig do its work
	super.swigDirectorDisconnect ();
    }

    /// ------------------ ///
    ///                    ///
    ///  UNotifyOnRequest  ///
    ///                    ///
    /// ------------------ ///

    protected native void registerNotifyOnRequest(long var,
						  String var_name,
						  boolean is_owned,
						  String obj_name,
						  String method,
						  String signature,
						  String return_type,
						  int    arg_number,
						  String[] types);


    private String[] classToStringArray(Class[] p) {
	String[] types = new String[p.length];
	for (int i = 0; i < p.length; ++i) {
	    types[i] = p[i].toString();
	}
	return types;
    }


    protected void UNotifyOnRequest (String var_name, Method m)
    {
	checkNotifyRegisteredMethod (m, "UNotifyOnRequest");
	String bytecode_sig = getMethodBytecodeSignature (m);
	Class[] p = m.getParameterTypes();
	String[] types = classToStringArray(p);
	registerNotifyOnRequest (0,
				 var_name,
				 false,
				 get__name (),
				 m.getName (),
				 bytecode_sig,
				 m.getReturnType().getName (),
				 p.length,
				 types);
    }

    protected void UNotifyOnRequest (UVar v, Method m)
    {
	checkNotifyRegisteredMethod (m, "UNotifyOnRequest");
	String bytecode_sig = getMethodBytecodeSignature (m);
	Class[] p = m.getParameterTypes();
	String[] types = classToStringArray(p);
	registerNotifyOnRequest (UVar.getCPtr (v),
				 v.getName(),
				 v.getOwned (),
				 get__name (),
				 m.getName (),
				 bytecode_sig,
				 m.getReturnType().getName (),
				 p.length,
				 types);
    }

    protected void UNotifyOnRequest (String var_name, String method_name)
    {
	Method m = findMethodFromName (this, method_name);
	UNotifyOnRequest (var_name, m);
    }

    protected void UNotifyOnRequest (String var_name,
				     String method_name,
				     String[] parameters_name)
    {
	Method m;
	try {
	    Class[] params = stringTypeToClassType (parameters_name);
	    Class obj_class = getClass ();
	    m = obj_class.getMethod (method_name, params);
	}
	catch (java.lang.ClassNotFoundException e) {
	    throw new RuntimeException (e);
	}
	catch (java.lang.NoSuchMethodException e) {
	    throw new RuntimeException (e);
        }
	UNotifyOnRequest (var_name, m);
    }


    protected void UNotifyOnRequest (UVar v, String method_name)
    {
	Method m = findMethodFromName (this, method_name);
	UNotifyOnRequest (v, m);
    }

    protected void UNotifyOnRequest (UVar v,
				     String method_name,
				     String[] parameters_name)
    {
	Method m;
	try {
	    Class[] params = stringTypeToClassType (parameters_name);
	    Class obj_class = getClass ();
	    m = obj_class.getMethod (method_name, params);
	}
	catch (java.lang.ClassNotFoundException e) {
	    throw new RuntimeException (e);
	}
	catch (java.lang.NoSuchMethodException e) {
	    throw new RuntimeException (e);
        }
	UNotifyOnRequest (v, m);
    }


    /// --------------- ///
    ///                 ///
    ///  UNotifyChange  ///
    ///                 ///
    /// --------------- ///

    protected native void registerNotifyChange(long var,
					       String var_name,
					       boolean is_owned,
					       String obj_name,
					       String method,
					       String signature,
					       String return_type,
					       int    arg_number,
					       String[] types);

    protected void UNotifyChange (String var_name, Method m)
    {
	checkNotifyRegisteredMethod (m, "UNotifyChange");
	String bytecode_sig = getMethodBytecodeSignature (m);
	Class[] p = m.getParameterTypes();
	String[] types = classToStringArray(p);
	registerNotifyChange (0,
			      var_name,
			      false,
			      get__name (),
			      m.getName (),
			      bytecode_sig,
			      m.getReturnType().getName (),
			      p.length,
			      types);
    }

    protected void UNotifyChange (UVar v, Method m)
    {
	checkNotifyRegisteredMethod (m, "UNotifyChange");
	String bytecode_sig = getMethodBytecodeSignature (m);
	Class[] p = m.getParameterTypes();
	String[] types = classToStringArray(p);
	registerNotifyChange (UVar.getCPtr (v),
			      v.getName(),
			      v.getOwned (),
			      get__name (),
			      m.getName (),
			      bytecode_sig,
			      m.getReturnType().getName (),
			      p.length,
			      types);
    }

    protected void UNotifyChange (String var_name, String method_name)
    {
	Method m = findMethodFromName (this, method_name);
	UNotifyChange (var_name, m);
    }

    protected void UNotifyChange (String var_name,
				  String method_name,
				  String[] parameters_name)
    {
	Method m;
	try {
	    Class[] params = stringTypeToClassType (parameters_name);
	    Class obj_class = getClass ();
	    m = obj_class.getMethod (method_name, params);
	}
	catch (java.lang.ClassNotFoundException e) {
	    throw new RuntimeException (e);
	}
	catch (java.lang.NoSuchMethodException e) {
	    throw new RuntimeException (e);
        }
	UNotifyChange (var_name, m);
    }


    protected void UNotifyChange (UVar v, String method_name)
    {
	Method m = findMethodFromName (this, method_name);
	UNotifyChange (v, m);
    }

    protected void UNotifyChange (UVar v,
				  String method_name,
				  String[] parameters_name)
    {
	Method m;
	try {
	    Class[] params = stringTypeToClassType (parameters_name);
	    Class obj_class = getClass ();
	    m = obj_class.getMethod (method_name, params);
	}
	catch (java.lang.ClassNotFoundException e) {
	    throw new RuntimeException (e);
	}
	catch (java.lang.NoSuchMethodException e) {
	    throw new RuntimeException (e);
        }
	UNotifyChange (v, m);
    }



    /// --------------- ///
    ///                 ///
    ///  UBindFunction  ///
    ///                 ///
    /// --------------- ///

    protected native void registerFunction (Object obj,
					    String obj_name,
					    String method,
					    String signature,
					    String return_type,
					    int    arg_number,
					    String[] types);

    protected void UBindFunction (Object obj, Method m)
    {
	Class[] p = m.getParameterTypes();

	if (p.length > 16) {

	    String msg = "Function \""+ m.getName () + "\" has " + p.length
		+ " arguments. You can't bind a function with more than "
		+ "16 arguments with UBindFunction.";
	    throw new RuntimeException (msg);
	}

	String bytecode_sig = getMethodBytecodeSignature (m);
	String[] types = classToStringArray(p);
	registerFunction (obj,
			  get__name (),
			  m.getName (),
			  bytecode_sig,
			  m.getReturnType().getName (),
			  p.length,
			  types);
    }

    protected void UBindFunction (Object obj,
				  String method_name)
    {
	Method m = findMethodFromName (obj, method_name);
	UBindFunction (obj, m);
    }

    protected void UBindFunction (String method_name)
    {
	Method m = findMethodFromName (this, method_name);
	UBindFunction (this, m);
    }

    protected void UBindFunctions(Object obj,
				  String ... method_names)
    {
	for (String method_name : method_names)
	    UBindFunction(obj, method_name);
    }

    protected void UBindFunctions(String ... method_names)
    {
	for (String method_name : method_names)
	    UBindFunction(this, method_name);
    }


    protected void UBindFunction (Object obj,
				  String method_name,
				  String[] parameters_name)
    {
	Method m;
	try {
	    Class[] params = stringTypeToClassType (parameters_name);
	    Class obj_class = obj.getClass ();
	    m = obj_class.getMethod (method_name, params);
	}
	catch (java.lang.ClassNotFoundException e) {
	    throw new RuntimeException (e);
	}
	catch (java.lang.NoSuchMethodException e) {
	    throw new RuntimeException (e);
        }
	UBindFunction (obj, m);
    }

    /// --------------- ///
    ///                 ///
    ///    USetTimer    ///
    ///                 ///
    /// --------------- ///

    protected native String registerTimerFunction (Object obj,
						 String obj_name,
						 double period,
						 String method,
						 String signature,
						 String return_type,
						 int    arg_number);

    protected String USetTimer (double period, Object obj, Method m)
	throws RuntimeException
    {
	Class[] p = m.getParameterTypes();
	if (p.length > 0) {

	    String msg = "Function \""+ m.getName () + "\" has " + p.length
		+ " arguments. You can only register functions with zero "
		+ " arguments with USetTimer.";
	    throw new RuntimeException (msg);
	}
	if (m.getReturnType() != int.class) {
	    String msg = "Return type of the function \""
		+ m.getName () + "\" is "+ m.getReturnType().getName ()
		+ ". You can only register functions with a return type of"
		+ " type int with USetTimer.";
	    throw new RuntimeException (msg);
	}

	String bytecode_sig = getMethodBytecodeSignature (m);
	return registerTimerFunction (obj,
				      get__name (),
				      period,
				      m.getName (),
				      bytecode_sig,
				      m.getReturnType().getName (),
				      m.getParameterTypes().length);
    }


    protected String USetTimer (double period,
				Object obj,
				String method_name,
				String[] parameters_name)
    {
	Method m;
	try {
	    Class[] params = stringTypeToClassType (parameters_name);
	    Class obj_class = obj.getClass ();
	    m = obj_class.getMethod (method_name, params);
	}
	catch (java.lang.ClassNotFoundException e) {
	    throw new RuntimeException (e);
	}
	catch (java.lang.NoSuchMethodException e) {
	    throw new RuntimeException (e);
        }
	return USetTimer (period, obj, m);
    }

    protected String USetTimer (double period,
				Object obj,
				String method_name)
    {
	Method m = findMethodFromName (obj, method_name);
	return USetTimer (period, obj, m);
    }

    /// --------------- ///
    ///                 ///
    ///     UBindVar    ///
    ///                 ///
    /// --------------- ///

    protected void UBindVar (UVar v, String name) {
	v.init (get__name (), name, getCtx_());
    }

    /// --------------- ///
    ///                 ///
    ///   UBindEvent    ///
    ///                 ///
    /// --------------- ///

    protected void UBindEvent (UEvent e, String name) {
	e.init (get__name(), name, getCtx_());
    }

    /// --------------- ///
    ///                 ///
    ///      UStart     ///
    ///                 ///
    /// --------------- ///

    public static void UStartRename (Class uobject_cls, String urbi_name)
    {
	/// Get the constructor that take a string
	Class string_cls;
	Constructor uobject_ctor;
	try {
	    string_cls = Class.forName ("java.lang.String");
	    Class[] params = {string_cls};
	    uobject_ctor = uobject_cls.getConstructor (params);
	}
	catch (java.lang.ClassNotFoundException e) {
	    throw new RuntimeException (e);
	}
	catch (java.lang.NoSuchMethodException e) {
	    throw new RuntimeException (e);
	}
	starterList.add (new UObjectStarter (urbi_name, uobject_ctor));
    }

    public static void UStart (Class uobject_cls)
    {
	String name = uobject_cls.getName ();
	String[] urbi_name = name.split ("\\.");
	if (urbi_name.length > 0) {
	    UStartRename(uobject_cls, urbi_name[urbi_name.length - 1]);
	}
    }

    public static void main (String argv[]) {
	/// Add program name at the begining of the argv array
	String[] new_argv = new String [argv.length + 1];
	for (int i = 0; i < argv.length; ++i) {
	    new_argv[i + 1] = argv[i];
	}
	new_argv[0] = "UObject";
	UrbiRoot root = new UrbiRoot("urbi-launch", false);
	urbi.main (new_argv.length, new_argv, root);
    }

    /// internal
    private void checkNotifyRegisteredMethod (Method m, String notifyName)
	throws RuntimeException
    {
	Class[] p = m.getParameterTypes();
	if (p.length > 1) {

	    String msg = "Function \""+ m.getName () + "\" has " + p.length
		+ " arguments. You can't register a function with more than "
		+ "1 arguments with " + notifyName + ".";
	    throw new RuntimeException(msg);
	}
	if ((m.getReturnType() != int.class) && (m.getReturnType() != void.class)) {
	    String msg = "Return type of the function \""
		+ m.getName () + "\" is "+ m.getReturnType().getName ()
		+ ". You can only register functions with a return type of"
		+ " type int or void with " + notifyName + ".";
	    throw new RuntimeException(msg);
	}
    }


    /// internal
    private static String getMethodBytecodeSignature(Method m)
    {
	return getMethodBytecodeSignature (m.getParameterTypes(),
					   m.getReturnType());
    }

    /// internal
    private static String getMethodBytecodeSignature(Class[] parameterTypes,
						     Class returnType)
    {
	StringBuffer sb = new StringBuffer();
	sb.append("(");
	for (int i=0; i<parameterTypes.length; i++)
	    sb.append(Type.make(parameterTypes[i]).getSignature());
	sb.append(")");
	sb.append(Type.make(returnType).getSignature());
	return sb.toString();
    }

    /// internal
    protected Method findMethodFromName (Object obj, String method_name)
	throws RuntimeException
    {
	Class obj_cls = obj.getClass ();
	Method[] methods = obj_cls.getMethods();
	Method res = null;
	for (int i = 0; i < methods.length; ++i) {
	    if (methods[i].getName() == method_name) {
		if (res == null)
		    res = methods[i];
		else
		{
		    String msg = "There are several methods with name "
			+ method_name + " in UObject "
			+ obj_cls.getName ()
			+ ", please specify the arguments to avoid ambiguities";
		    throw new RuntimeException(msg);
		}
	    }
	}
	if (res == null) {
	    String msg = "Can't find method with name "
		+ method_name + " in object "
		+ obj_cls.getName ();
	    throw new RuntimeException(msg);
	}
	return res;
    }

    /// internal
    protected Class[] stringTypeToClassType (String[] typeArray)
	throws java.lang.ClassNotFoundException
    {
	Class[] params = new Class[typeArray.length];
	for (int i = 0; i < typeArray.length; ++i) {
	    params[i] = Class.forName (typeArray[i]);
	}
	return params;
    }

    public void call(String object, String method, UValue v1, UValue v2, UValue v3, UValue v4, UValue v5, UValue v6) {
	super.call(object, method, new UAutoValue(v1), new UAutoValue(v2),
		   new UAutoValue(v3), new UAutoValue(v4), new UAutoValue(v5),
		   new UAutoValue(v6));
    }

    public void call(String object, String method, UValue v1, UValue v2, UValue v3, UValue v4, UValue v5) {
	super.call(object, method, new UAutoValue(v1), new UAutoValue(v2),
		   new UAutoValue(v3), new UAutoValue(v4), new UAutoValue(v5));
    }

    public void call(String object, String method, UValue v1, UValue v2, UValue v3, UValue v4) {
	super.call(object, method, new UAutoValue(v1), new UAutoValue(v2),
		   new UAutoValue(v3), new UAutoValue(v4));
    }

    public void call(String object, String method, UValue v1, UValue v2, UValue v3) {
	super.call(object, method, new UAutoValue(v1), new UAutoValue(v2),
		   new UAutoValue(v3));
    }

    public void call(String object, String method, UValue v1, UValue v2) {
	super.call(object, method, new UAutoValue(v1), new UAutoValue(v2));
    }

    public void call(String object, String method, UValue v1) {
	super.call(object, method, new UAutoValue(v1));
    }

    public void call(String object, String method) {
	super.call(object, method);
    }

    private static LinkedList<UObjectStarter> starterList = new LinkedList<UObjectStarter>();
}
